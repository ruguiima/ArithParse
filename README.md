# ArithParse

一个针对算术表达式的 LL(1) 与 LR(1) 语法分析示例，支持符号集：`{ n, +, -, *, /, (, ) }`。其中 `n` 表示数值占位符（简化为统一的终结符）

## 特性
- 基于给定的算术表达式文法进行 LL(1) 与 LR(1) 分析
- 输出详细分析过程，包括分析栈/输入串栈/动作（LL1）或动作序列（LR1）
- 统一符号与动作约定，便于对照调试与教学

## LL(1) 文法产生式
| 编号 | 产生式     |
|------|------------|
| 1    | E -> T A   |
| 2    | A -> + T A |
| 3    | A -> - T A |
| 4    | A -> ε     |
| 5    | T -> F B   |
| 6    | B -> * F B |
| 7    | B -> / F B |
| 8    | B -> ε     |
| 9    | F -> ( E ) |
| 10   | F -> num   |

说明：
- 终结符：`+ - * / ( ) num`
- 非终结符：`E A T B F`
- ε 表示空串

## LR(1) 文法产生式
| 编号 | 产生式      |
|------|-------------|
| 0    | E' -> E     |
| 1    | E -> E + T  |
| 2    | E -> E - T  |
| 3    | E -> T      |
| 4    | T -> T * F  |
| 5    | T -> T / F  |
| 6    | T -> F      |
| 7    | F -> ( E )  |
| 8    | F -> num    |

## 输入输出规范

输入（标准输入，单行）：
- 一个算术表达式，由以下字符构成：`{ n, +, -, *, /, (, ) }`
- 示例：`n+n*n`、`(n-n)/n`、`n*(n+n)`

### LL(1) 分析输出
- 输出为多行，每行包含三部分，用制表符 `\t` 分隔：
  1) 分析栈：以 `$` 表示栈底（左侧为栈底），元素为终结符或非终结符
  2) 输入串栈：以 `$` 表示栈底（右侧为栈底）
  3) 分析动作：`产生式编号` 或 `match` 或 `error` 或 `accept`

示例（片段，仅示意）：
- 分析栈：`$E`
- 输入串栈：`n+n$`
- 动作：`1`（表示使用产生式 1：`E -> T A`）

### LR(1) 分析输出
- 输出为多行，每行仅包含一个分析动作：
  - `产生式编号` 或 `shift` 或 `error` 或 `accept`
- 规定：第 1 步根据“分析栈仅有状态 0、输入串栈顶为第一个输入字符”来产生分析动作。

示例（片段，仅示意）：
- 第 1 步：`shift`
- 第 2 步：`8`（归约`F -> num`）

## 运行方式
- 从标准输入读取一行表达式
- 输出对应的 LL(1) 或 LR(1) 分析过程
- 使用 `cin/scanf` 读取，`cout/printf` 输出（实现依赖具体语言）

## 符号与动作约定
- `$` 表示栈底标记
- `num` 与输入中的 `n` 等价（如实现中将 `n` 规约为 `num`）
- `match`：终结符与输入栈顶匹配并弹出
- `accept`：成功完成分析
- `error`：当前无法继续有效分析（如预测或动作表无条目）

## 示例
输入：
```
n+n*(n-n)
```
LL(1) 输出（示意）：
```
$E    n+n*(n-n)$    1
$TA   n+n*(n-n)$    5
...（若干步）...
...    ...          accept
```
LR(1) 输出（示意）：
```
shift
shift
8
...（若干步）...
accept
```
